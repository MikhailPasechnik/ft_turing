digraph palindrom {
	node [shape=doublecircle]
	init
	HALT
	node [shape=circle]
	init -> match_A_right [label="A/  R"]
	init -> match_B_right [label="B/  R"]
	init -> match_C_right [label="C/  R"]
	init -> reset [label="' '/  R"]
	match_A_right -> match_A_right [label="A/A R"]
	match_A_right -> match_A_right [label="B/B R"]
	match_A_right -> match_A_right [label="C/C R"]
	match_A_right -> is_A [label="' '/  L"]
	match_B_right -> match_B_right [label="A/A R"]
	match_B_right -> match_B_right [label="B/B R"]
	match_B_right -> match_B_right [label="C/C R"]
	match_B_right -> is_B [label="' '/  L"]
	match_C_right -> match_C_right [label="A/A R"]
	match_C_right -> match_C_right [label="B/B R"]
	match_C_right -> match_C_right [label="C/C R"]
	match_C_right -> is_C [label="' '/  L"]
	is_A -> swap_A [label="A/A R"]
	is_A -> finish [label="' '/A R"]
	is_A -> init_fail_A [label="B/B L"]
	is_A -> init_fail_A [label="C/C L"]
	is_B -> swap_B [label="B/B R"]
	is_B -> finish [label="' '/B R"]
	is_B -> init_fail_B [label="A/A L"]
	is_B -> init_fail_B [label="C/C L"]
	is_C -> swap_C [label="C/C R"]
	is_C -> finish [label="' '/C R"]
	is_C -> init_fail_C [label="A/A L"]
	is_C -> init_fail_C [label="B/B L"]
	init_fail_A -> init_fail_A [label="A/A L"]
	init_fail_A -> init_fail_A [label="B/B L"]
	init_fail_A -> init_fail_A [label="C/C L"]
	init_fail_A -> fail [label="' '/A R"]
	init_fail_B -> init_fail_B [label="A/A L"]
	init_fail_B -> init_fail_B [label="B/B L"]
	init_fail_B -> init_fail_B [label="C/C L"]
	init_fail_B -> fail [label="' '/B R"]
	init_fail_C -> init_fail_C [label="A/A L"]
	init_fail_C -> init_fail_C [label="B/B L"]
	init_fail_C -> init_fail_C [label="C/C L"]
	init_fail_C -> fail [label="' '/C R"]
	fail -> fail [label="A/A R"]
	fail -> fail [label="B/B R"]
	fail -> fail [label="C/C R"]
	fail -> recover [label="' '/  R"]
	recover -> recover_A [label="A/  L"]
	recover -> recover_B [label="B/  L"]
	recover -> recover_C [label="C/  L"]
	recover -> no [label="' '/  L"]
	recover_A -> fail [label="' '/A R"]
	recover_B -> fail [label="' '/B R"]
	recover_C -> fail [label="' '/C R"]
	no -> HALT [label="' '/n R"]
	swap_A -> match_A_left [label="A/  L"]
	swap_A -> swap_A [label="' '/A L"]
	swap_B -> match_B_left [label="B/  L"]
	swap_B -> swap_B [label="' '/B L"]
	swap_C -> match_C_left [label="C/  L"]
	swap_C -> swap_C [label="' '/C L"]
	match_A_left -> match_A_left [label="A/A L"]
	match_A_left -> match_A_left [label="B/B L"]
	match_A_left -> match_A_left [label="C/C L"]
	match_A_left -> init [label="' '/A R"]
	match_B_left -> match_B_left [label="A/A L"]
	match_B_left -> match_B_left [label="B/B L"]
	match_B_left -> match_B_left [label="C/C L"]
	match_B_left -> init [label="' '/B R"]
	match_C_left -> match_C_left [label="A/A L"]
	match_C_left -> match_C_left [label="B/B L"]
	match_C_left -> match_C_left [label="C/C L"]
	match_C_left -> init [label="' '/C R"]
	finish -> reset [label="' '/  R"]
	reset -> reset_A [label="A/  L"]
	reset -> reset_B [label="B/  L"]
	reset -> reset_C [label="C/  L"]
	reset -> yes [label="' '/  L"]
	reset_A -> finish [label="' '/A R"]
	reset_B -> finish [label="' '/B R"]
	reset_C -> finish [label="' '/C R"]
	yes -> HALT [label="' '/y R"]
}
